// mm32at.cpp : Defines the exported functions for the DLL application.
//
#define DLL_EXPORT // DLL is defined for export in the mm32at.h header file
#include "mm32at.h"
#include <WinReg.h>

/* Call this user interrupt function to get the current total of particle hits */
void IncrementCtr(void* param)
{
	/* TODO: we could make the counter a little smarter by making this a 
	 * a structure and returning an arrray of time indicating the points 
	 * at which the counter was incremented.
	 */
	counter++;
}

//extern "C" 
//{
/* A simple accessor for getting the current value of the counter */
DECLDIR unsigned long ReturnCtr()
{
	return counter;
}

/* Function to reset the global "counter" */
DECLDIR void ResetCtr()
{
	counter = 0;
}

DECLDIR BYTE StartParticleCount(DSCB board)
{
	//  Structure defining interrupt 
	DSCUSERINT dscuserint;
	dscCancelOp(board);
	/* Error returned by the initialization of the user interrupt function call */
	BYTE result= 0;

	// Interrupts generated by triggers on a digital line
	dscuserint.intsource = USER_INT_SOURCE_INTERNAL;
	dscuserint.clksource = 0;	// Use the 10 MHz counter
	dscuserint.counter = 0;

	dscuserint.rate = 100.0;		// 0 means don't program the counter here
	result = dscUserInt(board, &dscuserint, (DSCUserInterruptFunction)IncrementCtr);
	/* exit function if an error is thrown */
	if (result != DE_NONE)
	{
		dscCancelOp(board);						// Cancel interrupt operations - there was a problem
		dscClearUserInterruptFunction(board);	//  Uninstall function from board
	}

	return result;	// Return the error; 0 = no error

}

/* Set the counter 0 source to either the onboard oscillator or J3/pin48 */
DECLDIR void setCtr0Src(unsigned char val, WORD address){

	// The address is the base address + 10
	struct CTR_CFG *ctr_cfg = (struct CTR_CFG *)(address + 10);

	ctr_cfg->src0 = val;

	return;
}

DECLDIR BYTE getCtrCfg(WORD address){

	//BYTE *cfg_Out = (BYTE *)(address + 10);


	return *(BYTE *)(address + 10);//cfg_Out;

}

/* Wrapper for access to AI interrupt scans (LV is not able to access the 
 * memory space pointed to by sample_val).  User must be sure to call 
 * dscADSetSettings() prior to the call of this function and initialize the
 * AIO.  This function will setup the memory space for the sample values.
 */
DECLDIR BYTE StartAIScan(DSCB board, DSCAIOINT dscaioint)
{
	//DSCS dscs;
	BYTE result = 0;

	dscaioint.sample_values = (SWORD*) malloc(sizeof(SWORD) * dscaioint.num_conversions);
	memset(dscaioint.sample_values, 0, sizeof(WORD) * dscaioint.num_conversions);

	/* Provide global access to the sample_values */
	sample_values = dscaioint.sample_values;

	/* Start the scan; if there is a problem, let the user know and get out */
	if ((result = dscADScanInt(board, &dscaioint)) != DE_NONE)
		return result;

/*	do
	{
		dscSleep(1000);
		dscGetStatus(board, &dscs);
	} while(dscs.op_type != OP_TYPE_NONE);*/

	return 0;
}

DECLDIR void GetAIData(DSCSAMPLE* data)
{
	data = sample_values;
}

/* This function is purely for testing the memory space of the variable counter */
DECLDIR int incrementClk()
{
	return ++counter;
}

//}

